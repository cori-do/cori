//! Schema definition types for auto-generated database schema.
//!
//! This module defines types that represent the database schema captured via
//! `cori db sync`. The schema definition is auto-generated and should not be
//! manually edited.
//!
//! # Schema Location
//!
//! By convention, the schema is stored at `schema/schema.yaml` relative to the
//! project root.

use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

use super::ConfigError;

/// Auto-generated database schema definition.
///
/// This structure captures the complete database schema including tables,
/// columns, foreign keys, indexes, and enum types. It is generated by
/// `cori db sync` and should not be manually edited.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SchemaDefinition {
    /// Schema version (semver format).
    pub version: String,

    /// Timestamp when the schema was captured.
    pub captured_at: String,

    /// Database information.
    pub database: DatabaseInfo,

    /// List of enabled database extensions.
    #[serde(default)]
    pub extensions: Vec<String>,

    /// Custom enum types defined in the database.
    #[serde(default)]
    pub enums: Vec<EnumDefinition>,

    /// Table definitions.
    pub tables: Vec<TableSchema>,
}

impl SchemaDefinition {
    /// Load schema definition from a YAML file.
    pub fn from_file(path: impl AsRef<Path>) -> Result<Self, ConfigError> {
        let content = fs::read_to_string(path.as_ref())?;
        Self::from_yaml(&content)
    }

    /// Parse schema definition from YAML content.
    pub fn from_yaml(content: &str) -> Result<Self, ConfigError> {
        serde_yaml::from_str(content).map_err(ConfigError::from)
    }

    /// Get a table by name.
    pub fn get_table(&self, name: &str) -> Option<&TableSchema> {
        self.tables.iter().find(|t| t.name == name)
    }

    /// Get an enum by name.
    pub fn get_enum(&self, name: &str) -> Option<&EnumDefinition> {
        self.enums.iter().find(|e| e.name == name)
    }
}

/// Database engine and version information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseInfo {
    /// Database engine type.
    pub engine: DatabaseEngine,

    /// Database version string.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// Supported database engines.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
#[derive(Default)]
pub enum DatabaseEngine {
    #[default]
    Postgres,
    Mysql,
    Mariadb,
    Sqlite,
    Sqlserver,
}


/// Custom enum type definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EnumDefinition {
    /// Enum type name.
    pub name: String,

    /// Database schema containing the enum.
    #[serde(default = "default_schema")]
    pub schema: String,

    /// Allowed enum values.
    pub values: Vec<String>,
}

/// Table schema definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TableSchema {
    /// Table name.
    pub name: String,

    /// Database schema containing the table.
    #[serde(default = "default_schema")]
    pub schema: String,

    /// Column definitions.
    pub columns: Vec<ColumnSchema>,

    /// Primary key column names.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub primary_key: Vec<String>,

    /// Foreign key definitions.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub foreign_keys: Vec<ForeignKey>,

    /// Index definitions.
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub indexes: Vec<Index>,
}

impl TableSchema {
    /// Get a column by name.
    pub fn get_column(&self, name: &str) -> Option<&ColumnSchema> {
        self.columns.iter().find(|c| c.name == name)
    }

    /// Get all column names.
    pub fn column_names(&self) -> Vec<&str> {
        self.columns.iter().map(|c| c.name.as_str()).collect()
    }

    /// Check if a column exists.
    pub fn has_column(&self, name: &str) -> bool {
        self.columns.iter().any(|c| c.name == name)
    }
}

/// Column schema definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ColumnSchema {
    /// Column name.
    pub name: String,

    /// Generic column type.
    #[serde(rename = "type")]
    pub column_type: ColumnType,

    /// Native database type (e.g., "character varying", "serial").
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub native_type: Option<String>,

    /// Whether the column allows NULL values.
    pub nullable: bool,

    /// Default value or expression.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub default: Option<serde_json::Value>,

    /// Maximum length for string types.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub max_length: Option<u32>,

    /// Reference to enum type name (if column_type is Enum).
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enum_name: Option<String>,
}

/// Generic column types.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
#[derive(Default)]
pub enum ColumnType {
    String,
    Text,
    Integer,
    Bigint,
    Smallint,
    Decimal,
    Float,
    Double,
    Boolean,
    Date,
    Time,
    Datetime,
    Timestamp,
    Uuid,
    Json,
    Jsonb,
    Binary,
    Array,
    Enum,
    #[default]
    Unknown,
}


/// Foreign key definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForeignKey {
    /// Foreign key constraint name.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Column names in the current table.
    pub columns: Vec<String>,

    /// Referenced table and columns.
    pub references: ForeignKeyReference,

    /// Action on delete.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on_delete: Option<ForeignKeyAction>,

    /// Action on update.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub on_update: Option<ForeignKeyAction>,
}

/// Foreign key reference (target table and columns).
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ForeignKeyReference {
    /// Referenced table name.
    pub table: String,

    /// Referenced table schema.
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub schema: Option<String>,

    /// Referenced column names.
    pub columns: Vec<String>,
}

/// Foreign key actions.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ForeignKeyAction {
    NoAction,
    Restrict,
    Cascade,
    SetNull,
    SetDefault,
}

/// Index definition.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Index {
    /// Index name.
    pub name: String,

    /// Indexed column names.
    pub columns: Vec<String>,

    /// Whether the index enforces uniqueness.
    #[serde(default)]
    pub unique: bool,
}

fn default_schema() -> String {
    "public".to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parse_schema_definition() {
        let yaml = r#"
version: "1.0.0"
captured_at: "2025-01-08T10:30:00Z"
database:
  engine: postgres
  version: "16.1"
extensions:
  - uuid-ossp
enums:
  - name: ticket_status
    schema: public
    values: [open, in_progress, resolved]
tables:
  - name: customers
    schema: public
    columns:
      - name: id
        type: uuid
        nullable: false
      - name: name
        type: string
        nullable: false
        max_length: 255
    primary_key: [id]
"#;

        let schema = SchemaDefinition::from_yaml(yaml).unwrap();
        assert_eq!(schema.version, "1.0.0");
        assert_eq!(schema.database.engine, DatabaseEngine::Postgres);
        assert_eq!(schema.enums.len(), 1);
        assert_eq!(schema.tables.len(), 1);
        assert_eq!(schema.tables[0].name, "customers");
        assert_eq!(schema.tables[0].columns.len(), 2);
    }

    #[test]
    fn test_get_table() {
        let yaml = r#"
version: "1.0.0"
captured_at: "2025-01-08T10:30:00Z"
database:
  engine: postgres
tables:
  - name: users
    schema: public
    columns:
      - name: id
        type: integer
        nullable: false
  - name: orders
    schema: public
    columns:
      - name: id
        type: integer
        nullable: false
"#;

        let schema = SchemaDefinition::from_yaml(yaml).unwrap();
        assert!(schema.get_table("users").is_some());
        assert!(schema.get_table("orders").is_some());
        assert!(schema.get_table("nonexistent").is_none());
    }
}
